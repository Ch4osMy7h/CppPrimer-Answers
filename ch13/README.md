## 13.1

> 拷贝构造函数是什么？什么时候使用它？

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。当使用**拷贝初始化**时，我们会用到拷贝构造函数。

##13.6

> 拷贝复制运算符是什么？什么时候使用它？合成拷贝赋值运算符什么时候工作？什么时候会生成拷贝赋值运算符？

拷贝赋值运算符是一个名为 `operator=` 的函数。当赋值运算发生时就会用到它。合成拷贝赋值运算符可以用来禁止该类型对象的赋值。如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。

##13.14

> 假定 numbered 是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为 mysn 的数据成员中。假定 numbered 使用合成的拷贝控制成员，并给定如下函数：

三个**相同**的数字

##13.15

>假定numbered 定义了一个拷贝构造函数，能生成一个新的序列号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？

会改变，拷贝函数调用了五次，结果为三个**不同**的数字

#13.16

>如果 f 中的参数是 const numbered，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？

会改变，拷贝函数调用了两次。

#13.23

>比较上一节练习中你编写的拷贝控制成员和这一节中的代码。确定你理解了你的代码和我们的代码之间的差异。

#13.24

>如果本节的 HasPtr 版本未定义析构函数，将会发生什么？如果未定义拷贝构造函数，将会发生什么？

如果未定义析构函数，将会发生**内存泄漏**；
如果未定义拷贝构造函数，将不会拷贝一个`string`而是直接拷贝指针的值。

#13.25

>假定希望定义 StrBlob 的类值版本，而且希望继续使用 shared_ptr，这样我们的 StrBlobPtr 类就仍能使用指向vector的 weak_ptr 了。你修改后的类将需要一个拷贝的构造函数和一个拷贝赋值运算符，但不需要析构函数。解释拷贝构造函数和拷贝赋值运算符必须要做什么。解释为什么不需要析构函数。

#13.29

>解释swap(HasPtr&, HasPtr&)中对swap的调用不会导致递归循环。

因为``HasPtr``函数中``swap``调用的是``std::swap``

#13.30

#13.31

#13.32
#13.33
#13.34
#13.35
#13.36
